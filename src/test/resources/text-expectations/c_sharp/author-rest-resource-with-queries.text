using Vlingo.Xoom.Actors;
using Vlingo.Xoom.Common;
using Vlingo.Xoom.Common.Serialization;
using Vlingo.Xoom.Http;
using Vlingo.Xoom.Http.Resource;
using Vlingo.Xoom.Lattice.Grid;
using Io.Vlingo.Xoomapp.Model;
using Io.Vlingo.Xoomapp.Model.Author;
using Io.Vlingo.Xoomapp.Infrastructure;
using Io.Vlingo.Xoomapp.Infrastructure.Persistence;
using Vlingo.Xoom.Turbo;
using static Vlingo.Xoom.Http.ResponseStatus;

namespace Io.Vlingo.Xoomapp.Infrastructure.Resource;

/**
 * See <a href="https://docs.vlingo.io/xoom-turbo/xoom-annotations#resourcehandlers">@ResourceHandlers</a>
 */
public class AuthorResource: DynamicResourceHandler
{
  private readonly World _world;
  private readonly IAuthorQueries _queries;

  public AuthorResource(World world): base(world.Stage)
  {
      _world = world;
      _queries = ComponentRegistry.WithType<QueryModelStateStoreProvider>().IAuthorQueries;
      Routes = ResourceBuilder.Resource("AuthorResource",
            ResourceBuilder.Post("/authors")
            .Body<AuthorData>()
            .Handle(WithName),
            ResourceBuilder.Patch("/authors/{id}/rank")
            .Param<string>()
            .Body<AuthorData>()
            .Handle(ChangeRank),
            ResourceBuilder.Patch("/authors/{id}/related-author")
            .Param<string>()
            .Body<AuthorData>()
            .Handle(RelateAuthor),
            ResourceBuilder.Patch("/authors/{id}/related-authors")
            .Param<string>()
            .Body<AuthorData>()
            .Handle(RelateAuthors),
            ResourceBuilder.Put("/authors/{id}/related-authors")
            .Param<string>()
            .Body<AuthorData>()
            .Handle(ReplaceAllRelatedAuthors),
            ResourceBuilder.Delete("/authors/{id}/related-author")
            .Param<string>()
            .Param<AuthorData>()
            .Handle(UnrelateAuthor),
            ResourceBuilder.Patch("/authors/{id}/tag")
            .Param<string>()
            .Body<AuthorData>()
            .Handle(AddTag),
            ResourceBuilder.Patch("/authors/{id}/tags")
            .Param<string>()
            .Body<AuthorData>()
            .Handle(AddTags),
            ResourceBuilder.Put("/authors/{id}/tags")
            .Param<string>()
            .Body<AuthorData>()
            .Handle(ReplaceTags),
            ResourceBuilder.Delete("/authors/{id}/tags")
            .Param<string>()
            .Param<AuthorData>()
            .Handle(RemoveTag),
            ResourceBuilder.Patch("/authors/{id}/rank")
            .Param<string>()
            .Body<AuthorData>()
            .Handle(ChangeRank),
            ResourceBuilder.Patch("/authors/{id}/status")
            .Param<string>()
            .Handle(MakeUnavailable),
            ResourceBuilder.Get("/authors")
            .Handle(Authors),
            ResourceBuilder.Get("/authors/{id}")
            .Param<string>()
            .Handle(AuthorOf)
        );
  }

  public ICompletes<Response> WithName(AuthorData data)
 => IAuthor.WithName(_world.Stage, data.Name, data.AvailableOn)
      .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Created, Headers.Of(ResponseHeader.Of(ResponseHeader.Location, Location(state.Id))), JsonSerialization.Serialized(AuthorData.From(state)))))
      .Otherwise<Response>(arg => Response.Of(NotFound))
      .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> ChangeRank(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.ChangeRank(data.Rank))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> RelateAuthor(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.RelateAuthor(data.RelatedAuthor))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> RelateAuthors(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.RelateAuthors(data.RelatedAuthors))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> ReplaceAllRelatedAuthors(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.ReplaceAllRelatedAuthors(data.RelatedAuthors))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> UnrelateAuthor(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.UnrelateAuthor(data.RelatedAuthor))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> AddTag(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.AddTag(data.Tag))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> AddTags(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.AddTags(data.Tags))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> ReplaceTags(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.ReplaceTags(data.Tags))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> RemoveTag(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.RemoveTag(data.Tag))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> ChangeRank(string id, AuthorData data)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.ChangeRank(data.Rank))
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> MakeUnavailable(string id)
 => Resolve(id)
        .AndThenTo<ICompletes<AuthorState>>(author => author.MakeUnavailable())
        .AndThenTo<ICompletes<Response>>(state => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(AuthorData.From(state)))))
        .Otherwise<Response>(noGreeting => Response.Of(NotFound))
        .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> Authors() => _queries.Authors()
    .AndThenTo<ICompletes<Response>>(data => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(data))))
    .Otherwise<Response>(arg => Response.Of(NotFound))
    .RecoverFrom(e => Response.Of(InternalServerError));

  public ICompletes<Response> AuthorOf(string id) => _queries.AuthorOf(id)
    .AndThenTo<ICompletes<Response>>(data => Vlingo.Xoom.Common.Completes.WithSuccess(EntityResponseOf(Ok, JsonSerialization.Serialized(data))))
    .Otherwise<Response>(arg => Response.Of(NotFound))
    .RecoverFrom(e => Response.Of(InternalServerError));

  public override Vlingo.Xoom.Http.Resource.Resource Routes { get; }

  protected ContentType ContentType => Vlingo.Xoom.Http.ContentType.Of("application/json", "charset=UTF-8");

  private string Location(string id) => "/authors/" + id;

  private ICompletes<IAuthor> Resolve(string id)
  {
    var address = _world.Stage.AddressFactory.From(id);
    return _world.Stage.ActorOf<IAuthor>(address, Definition.Has(typeof(AuthorEntity), Definition.Parameters(id)));
  }

}
